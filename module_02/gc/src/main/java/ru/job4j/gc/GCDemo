Для каждого объекта выделяется память на:
•	Заголовок объекта - 2 машинных слова (8 байт – 32-х разрядные системы, 16 – 64-х);
•	Память для примитивных типов;
•	Память для ссылочных типов;
•	Смещение/выравнивание (несколько неиспользуемых байт, что размещаются после данных самого объекта. Это сделано для того, чтобы адрес в памяти всегда был кратным машинному слову, для ускорения чтения из памяти + уменьшения количества бит для указателя на объект + предположительно для уменьшения фрагментации памяти. В java размер любого объекта кратен 8 байтам!)

В нашем случае (64-х):
public class User {
    public String name;
}

new User (24 байта)
•	Заголовок – 16 байт
•	Ссылка на String name – 8 байт
•	Смещение – 0 байт
new String (40 байта):
•	Заголовок – 16 байт
•	Поля int (offset, count, hash)  - 4 * 3 = 12 байт
•	Ссылка на char[] -  8 байт
•	Смещение – 4 байта
new char[10] (40 байта):
•	Заголовок – 16 байт
•	Поля int (length)  - 4 * 1 = 4 байта
•	Примитивы char  - 10символов * 2 = 20 байт
•	Смещение – 0 байт

Размер полученного объекта равен 104 байта. Поскольку объекты будут добавляться в массив, то к этой сумме следует прибавить еще 8 байт издержек на ссылку. Итого 112 байта на объект.
Первый запуск программы с выделением 8мб (параметром VM options -Xmx8m) показал, что свободная память перед заполнением массива составляет порядка 4_200_000 байт.  Таким образом в памяти может поместиться максимум 37 000 объектов.
При 30 000 объектов после обнуления ссылки на массив (при выходе из цикла) происходит вызов finalize(), что и подтверждается выводом на консоль.
Тем не мене до 37 000 количество объектов поднять не удается и уже после превышения 30 000 получаем OutOfMemoryError. Либо расчет памяти объекта не верен, либо имеют место быть еще какие-то сопутствующие издержки???
